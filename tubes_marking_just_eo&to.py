# -*- coding: utf-8 -*-
"""Tubes_marking_just_EO&TO

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ILJtsl3Be7vIwHkrBFNyVp5eRXOo_uCz
"""

!pip install easyocr
import cv2 as cv
import easyocr

from glob import glob
import cv2 as cv

import time

!pip install ffmpeg

import ffmpeg

from google.colab import drive
drive.mount('/content/gdrive')


DATA_PATH = '/content/gdrive/MyDrive/CV_project/'

# поворот видео на 90 градусов против часовой стрелки  
!ffmpeg -i {DATA_PATH + 'tubes_2.mp4'} -vf "transpose=2" {DATA_PATH + 'tubes_2_rotated.mp4'}

from PIL import Image

import matplotlib.pyplot as plt

#нарезка повернутого видер на кадры с нужной частотой (для теста можно вырезать кусок видео)
#!ffmpeg -i {DATA_PATH + 'tubes_1_rotated.mp4'} -vf fps=1 -ss 00:00:01 -t 00:02:00 -vsync 0 -qscale:v 2 %6d.jpeg
!ffmpeg -i {DATA_PATH + 'tubes_2_rotated.mp4'} -vf fps=1 -vsync 0 -qscale:v 2 %6d.jpeg

!pip install transformers
from transformers import TrOCRProcessor, VisionEncoderDecoderModel
import requests
from PIL import Image
model_version = 'microsoft/trocr-large-printed' #выбор версии модели трансформера - 
                                                #распознавание больших печатных символы
processor = TrOCRProcessor.from_pretrained(model_version)
model = VisionEncoderDecoderModel.from_pretrained(model_version)

#ГОЛОСОВАНИЕ за самую "популярную" маркировку с помощью EasyOCR и 
#распознавание даты и времени с помошью TrOCR


start = time.time()

dict_names = {}
dict_fnames = {}
reader = easyocr.Reader(['en'])


i = 1 

step = 15 #параметр - количество кадров, после появления кадра с новой трубой, для которых распознается
          # маркировка для дальнейшего "голосования"

while True:
  filename = str(i) + '.jpeg'
  tube_list = []
  count_dict = {}
  while len(filename) != 11:
        filename = '0'+ filename 
  if filename in glob('*.jpeg'):
    img = cv.imread(filename)
    img_cropped = img[500:650, 100:400] # Кроп в постоянном месте кадра - опционально, для улучшения качества. 
                                        # В дальнейшем необходимо заменить на обученный детектор YOLO
    #binary_inv = cv.threshold(img_cropped,230,255,cv.THRESH_BINARY_INV)[1]
    bounds = reader.readtext(img_cropped, allowlist='0123456789',detail=1, width_ths=1.0)

    for sym in bounds:

      if len(sym[1]) >= 7: #проверяем, не яволяется ли полученный номер артефактом - содержит более 7 символов

        tube_name = sym[1][-7:]
        tube_list.append(tube_name)
      
    if len(tube_list) == 0:  # если "новой" трубы не найдено, переходим к следующему кадру
      i += 1
    else:                   # в ином случае првоеряем ближайшие *step* кадров д
      for k in range(1, step):
        id = int(filename[:6])
        new_id = str(id + k) + '.jpeg'
        new_filename = new_id
        #print('NEW_FILENAME ', new_filename)
        while len(new_filename) != 11:
          new_filename = '0'+ new_filename
        if new_filename not in glob('*.jpeg'):
          break
        img = cv.imread(new_filename)
        img_cropped = img[500:650, 100:400]
        #binary_inv = cv.threshold(img_cropped,230,255,cv.THRESH_BINARY_INV)[1]
        bounds = reader.readtext(img_cropped, allowlist='0123456789',detail=1, width_ths=1.0)

        for sym in bounds:
          if len(sym[1]) >= 7:
            tube_name = sym[1][-7:]
            tube_list.append(tube_name)  #запись полученной маркировки в список для "голосования"
      print('TUBE_LIST', tube_list)
        
      for elem in tube_list:
        if elem not in dict_names.values():
          if elem not in count_dict.keys():
            count_dict[elem] = 1
          else:
            count_dict[elem] += 1
      print('DICT ', filename, count_dict)

      vote = max(count_dict, key=count_dict.get)

 ########### ЧАСТЬ, ОТВЕЧАЮЩАЯ ЗА РАСПОЗНАВАНИЕ ДАТЫ И ВРЕМЕНИ ###########     
      if vote not in dict_names.values():
            
        image_rot = Image.open(filename).transpose(Image.ROTATE_270) # поворот кадра по часовой стрелке на 90 градусов
        filename_rot = filename[:-5] + '_rotated.jpeg'
        image_rot.save(filename_rot)
        image = cv.imread(filename_rot)[0:100, 0:700]
        binary_inv = cv.threshold(image,230,255,cv.THRESH_BINARY_INV)[1] # пороговая инвариантная бинаризация
        pixel_values = processor(images=binary_inv, return_tensors="pt").pixel_values
        generated_ids = model.generate(pixel_values)
        generated_text = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]

        dict_names[generated_text] = vote  #формирование итогового словаря
        dict_fnames[filename] = (generated_text, vote)



      i += step

        
  else:
    break


    
dict_names = dict(sorted(dict_names.items()))
dict_names

#Расчет метрик для оценки качества модели распознавания маркировок

with open ('tubes_1.txt', 'r') as file:
  true_marks = file.readlines()
  true_marks = [line.rstrip('\n') for line in true_marks]

waste = 0
coincidence = 0
for mark in true_marks:
  if mark in dict_names.values():
    coincidence += 1
for name in dict_names.values():
  if name not in true_marks:
    waste += 1

acc_easy = coincidence/len(true_marks)*100
waste_perc = waste/len(dict_names)*100

print('Точность реализации с помощью EasyOCК c голосованием: ', acc_easy)
print('Процент лишних и неверных маркировок: ',waste_perc)